define([
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/window",
	"dojo/topic",
	"dojo/dom-class",
	"../queue/utility",
	"../aspect",
	"../queue/SequenceGroup",
	"../queue/Animation",
	"../event/QueueEvent",
	"../event/QueueBubbleEvent",
	"../log",
	"../shared",
	"../util",
	"./registry"
], function(declare, lang, win, topic, domClass, utility, xcaspect, SequenceGroup, Animation, QueueEvent, QueueBubbleEvent, log, shared, util, transitionRegistry){

var onDebug = function(e){
	console.log(e.currentTarget.declaredClass,"\n  ",e.currentTarget.getNameCanonical(), "fired `"+e.type+"` for","\n    ",e.target.getNameCanonical());
};
var _log = function($args, $information){
	var t = $information.target;
	var name = t.id||t.apiName||t.name||t.declaredClass||Object.prototype.toString.call(t);
	log("transition","`"+this.declaredClass+"::"+$args.callee.nom+"()`\r\nprevented execution of\r\n `"+name+"::"+$information.methodName+"()`");
}; 
var _Transition = declare(
	"excentos.transition._Transition",
	[SequenceGroup, utility],
{
	//stageChangeController
	controller: null,
	//array with "refresh" method calls that were prevented via "aspect around"
	_refreshStack: null,
	//"aspect around" handlers with ability to recreate the aspect
	_preventCallAspectObjects: null,
	
	haltOnError: true,
	
	// transitioningCssClass: String
	//		defines the css class that is being applied to the HTML body to
	//		indicate that a specific transition is currently running.
	//		If not set directly the class will be autogenerated by "transitioningBaseCssClass"+name
	//		which reads something like "xc_transition_MyTransition"
	transitioningCssClass: "",
	
	constructor: function(){
		this._refreshStack = {};
		this._preventCallAspectObjects = [];
		this.controller = shared.stageChangeController;
	},
	
	_generateDefaultName: function(){
		this.inherited(arguments);
		var id = this.id;
		if(transitionRegistry.byId(id))throw new Error(this.declaredClass+" id conflict - '"+id+"' already registered!");
	},
	
	init: function(){
		this.inherited(arguments);

		if(!this.transitioningCssClass){
			this.generateCssClass();
		}
		
		return this;
	},

	disable: function(/*Boolean*/ bool){
		var disabled = this.inherited(arguments);
		if(disabled){
			this._removePreventCalls();
		}else {
			this._recreatePreventCalls();
		}
	},
	
	truncateRefreshStack: function(){
		if(xcInitial.debug){
			var debugStack = util.toArray(this._refreshStack);
			log("transition","`"+this.name+"::"+arguments.callee.nom+"()`\r\nvoids "+debugStack.length+" prevented method call(s):\r\n "+debugStack+"");
		}
			
		this._refreshStack = {};
	},
	
	generateCssClass: function(){
		this.transitioningCssClass = excentos.transition.transitioningBaseCssClass+"_"+this.name;
	},
	
	_applyEventHandlers: function(){
		this.inherited(arguments);
		//internal event connections are being applied
		this.addEventListener(QueueEvent.BEGIN, 	this._handleOnExecutionBegin);
		this.addEventListener(QueueEvent.PROGRESS,	this._handleOnExecutionProgress);
		this.addEventListener(QueueEvent.END, 		this._handleOnExecutionEnd);
		topic.subscribe(this.controller.SIGNAL_MOVE_TO_STAGE, lang.hitch(this, "onMoveToStage"));
		//delegate to transition controller
		xcaspect.after(shared.behavior, "onError", this._handleOnError, this);
		
		this.debug(this.debugMode);
	},

	debug: function(/*Number*/ mode){
		this.removeEventListener(QueueBubbleEvent.BEGIN, onDebug);
		this.removeEventListener(QueueBubbleEvent.END, onDebug);
		this.removeEventListener(QueueBubbleEvent.PROGRESS, onDebug);
		
		mode&1 && this.addEventListener(QueueBubbleEvent.BEGIN, 	onDebug);
		mode&2 && this.addEventListener(QueueBubbleEvent.END, 	onDebug);
		mode&4 && this.addEventListener(QueueBubbleEvent.PROGRESS,onDebug);
	},
	
	_handleOnError: function(){
		if(this.haltOnError){
			this.stop();
			this.cleanup();
		}
	},
	
	preventAndStart: function(/*Object*/ target, /*String*/ methodName){
		//summary:
		// prevents the execution of the original trigger and starts the transition
		// the trigger will be added to the refreshStack and can be called in the refresh phase
		return this.preventCall(target, methodName, this._preventAndStartCallback, this);
	},
	
	preventRefresh: function(/*Object*/ target, /*String*/ methodName){
		//summary: 
		// prevents a call to a function via aspect around and recalls it during the refresh phase
		return this.preventCall(target, methodName, this._preventRefreshCallback, this);
	},
	
	preventCall: function(/*Object*/ target, /*String*/ methodName, /*Function?*/ callback, /*Object?*/ context){

		callback = callback || this._preventDefaultCallback;
		context = context || this;

		var preventCallAspectObject = new PreventCallAspect(target, methodName, callback, context);

		this._preventCallAspectObjects.push(preventCallAspectObject);
		return preventCallAspectObject.aspectHandle;
	},

	_removePreventCalls: function(){
		var i = this._preventCallAspectObjects.length;
		while(i-->0){
			var obj = this._preventCallAspectObjects[i];
			obj.remove();
		}
	},
	_recreatePreventCalls: function(){
		var i = this._preventCallAspectObjects.length;
		while(i-->0){
			var obj = this._preventCallAspectObjects[i];
			obj.create();
		}
	},

	//TODO: refactor the stack - it should not override calls from the same methodName, add context awareness (requires some kind of "Dictionary")
	addToRefreshStack: function(originalFuncCall, aspectInformation /*Object*/){
		var t = aspectInformation.target;
		var identifier = t.id||t.name||t.declaredClass||new Date().getTime();
			identifier += "::"+aspectInformation.methodName;
		this._refreshStack[identifier] = originalFuncCall;
	},
	
	_preventAndStartCallback: function(/*Function*/ originalFuncCall, /*Object*/ information){
		//normally we `start()` and the call-prevention / refreshStack __could__ kick in (doesnt have to)
		//here we have the case that we already prevented the call and the refreshStack __must__ kick in
		this.isActive() && this.truncateRefreshStack(); //truncate in case of override-start
		
		_log.call(this, arguments, information);
		this.addToRefreshStack(originalFuncCall, information);
		
		this.start();
	},
	
	_preventRefreshCallback: function(/*Function*/ originalFuncCall, /*Object*/ information){			
		if(!this.isActive()){
			originalFuncCall();
		}else {
			_log.call(this, arguments, information);
			this.addToRefreshStack(originalFuncCall, information);
		}
	},
	_preventDefaultCallback: function(/*Function*/ originalFuncCall, /*Object*/ information){
		// summary:
		//		AOP advice being called whenever the original function gets called.
		//		The original function is executed only if the transition is in an idle state
		//	originalFuncCall:
		//		A wrapped function that executes the originally executed method (incl. arguments) in original context
		//	information:
		//		Holds information about the original function call
		//		{
		//			target: *,
		//			methodName: String,
		//			arguments: Array
		//		}
		if(!this.isActive()){
			//console.info("executing "+information.methodName+"()");
			originalFuncCall();
		}else {
			//TODO: in order to implement some robust transition where the user can click anywhere during a transition
			//		 we need to know the position of the overall transition sequence.
			_log.call(this, arguments, information);
		}
	},
	
	//runs through the stack of captured methods calls and re-calls them
	processRefreshStack: function(){
		for(var funcName in this._refreshStack){
			log("transition","`"+this.name+"::"+arguments.callee.nom+"()`\r\nrelease prevented method\r\n `"+funcName+"()`");
			typeof this._refreshStack[funcName] == "function" && this._refreshStack[funcName]();
			delete this._refreshStack[funcName];
		}
	},
	
	initMethodCallPrevention: function(){
		// summary: 
		//		creates aop arounds for methods that should not be executed or should just get delayed
		// tags: interface
	},
	
	cleanup: function(){
		this.inherited(arguments);
		this.processRefreshStack();
		this.removeTransitioningCssClassState();
	},
	
	_handleOnExecutionBegin: function(/*excentos.event.QueueEvent*/ e){
		this.addTransitioningCssClassState();
	},
	_handleOnExecutionProgress: function(/*excentos.event.QueueEvent*/ e){
		// tags: interface
	},
	_handleOnExecutionEnd: function(/*excentos.event.QueueEvent*/ e){
		this.removeTransitioningCssClassState();
	},
	
	addTransitioningCssClassState: function(){
		this._publishTransitioningCssClassState(true);
	},
	removeTransitioningCssClassState: function(){
		this._publishTransitioningCssClassState(false);
	},
	_publishTransitioningCssClassState: function(/*Boolean*/ add){
		domClass.toggle(win.body(), this.transitioningCssClass, add);
	},
	
	onMoveToStage: function(/*Object*/ stageChangeObject){}
});

//TODO: create TransitionController to avoid static package vars
excentos.transition.SPEED = function(speed){
	speed = speed == undefined ? Animation.STATIC_VAR.SPEED : speed;
	return Animation.STATIC_VAR.SPEED = speed;
};
excentos.transition.transitioningBaseCssClass =  "xc_transition";


	var PreventCallAspect = declare(null, {

		target: null,
		methodName: "",
		advice:  null,
		context: null,
		aspectHandle: null,

		constructor: function(/*Object*/ target, /*String*/ methodName, /*Function*/ advice, /*Object*/ context){
			this.target = target;
			this.methodName = methodName;
			this.advice = advice;
			this.context = context;

			this.create();
		},

		remove: function(){
			this.aspectHandle && this.aspectHandle.remove();
			this.aspectHandle = null;
		},
		create: function(){
			this.remove();
			this.aspectHandle = xcaspect.around(this.target, this.methodName, this.advice, this.context);
		}
	});

return _Transition;

});
